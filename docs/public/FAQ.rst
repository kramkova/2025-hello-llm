.. _faq-label:

Часто задаваемые вопросы
========================

.. contents:: Content:
   :depth: 2


Лабораторные работы
-------------------

1. Ошибка Argument 1 to "get_top_n" has incompatible type "Dict[str, int]"; expected "Dict[str, Union[int, float]]" [arg-type]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Это проблема часто встречается в лабораторной работе ``lab_1_keywords_tfidf`` и легко решаема.

Обычно, за этой ошибкой следуют следующие примечания:

* ``note: "Dict" is invariant -- see [link]``
* ``note: Consider using "Mapping" instead, which is covariant in the value type``

Чтобы решить проблемы, достаточно внимательно изучить описание задачи.
Там написано, что студентам нужно продемонстрировать использование
``get_top_n`` с двумя типами словарей: словарём, содержащим значения ``TF-IDF``,
и словарём, содержащим значения хи-квадрата. Оба эти словаря содежат значения
типа ``float``.

Проблема возникает, если использовать ``get_top_n`` на словаре частот,
что **не** требуется в описании. Частотный словарь содержит целочисленные
значения, которые не сочетаются с типами функции, и это вызывает ошибки
в ``MyPy``.

Чтобы решить проблему, используйте ``get_top_n`` только со словарями с типом
значений ``float``.

Похожие проблемы часто возникают из-за того, как ``MyPy`` интерпретирует типы.
Обычно для их решения достаточно сделать дополнительную проверку значений
перед передачей аргуметов в фунции.

2. Ошибка импорта Cannot find implementation or library stub for module named "main" [import]
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Предположим, что структура Вашег проекта выглядит так:

.. code:: text

   +-- 2025-2-level-labs
       +-- config
       +-- docs
       +-- lab_1_keywords_tfidf
           +-- assets
           +-- tests
           +-- main.py
           +-- start.py
           +-- settings.json
           +-- README.rst
       +-- seminars
   ...

Вы хотите импортировать функции из файла ``main.py`` в файл ``start.py``.
Чтобы сделать это, вспомните, что программа смотрит на Ваш код из корневой
папки. Это значит, что на самом деле Ваш файл ``main.py`` имеет путь
``lab_1_keywords_tfidf/main.py``.

Поэтому Вам нужно импортировать функции из ``main.py`` в ``start.py``
следующим образом:

.. code:: py

   from lab_1_keywords_tfidf.main import <functions you want to import>


3. Ошибка Argument 1 to <function name> Has incompatible type "Optional[<certain type>]"; expected "[<certain type>]"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

В некоторых лабораторных работах существует необходимость проверять
входные значения. В других словах, помимо логики функции, Вы должны
удостовериться, что все передаваемые аргументы действительно являются
правильных типов.

Обычно это происходит когда мы используем несколько функций подрят
из-за того, что ``MyPy`` не хочет, чтобы, например, во вторую по счёту
функцию попало специальное значение ``None``, так как оно часто используется
как индикатор наличия неправильных значений. ``MyPy`` видит, что значение
может быть ``None`` и не хочет потенциально передавать его в следующую
функцию — оно уже неправильное.

Чтобы избежать ошибок в ``MyPy``, следовать сделать дополнительную проверку
на ``None`` перед передачей значения в следующую функцию.

Например, у Вас есть две функции, представленные ниже.
Первая объединяет два списка в один,
а вторая суммирует все элементы одного списка.

.. code:: py

   def function1(arg1: list[int], arg2: list[int]) -> list[int] | None:
       if not arg1 or not arg2:
           return None
       return arg1 + arg2

   def function2(arg: list[int]) -> int | None:
       if not arg:
           return None
       return sum(arg)

Мы хотим использовать их по-порядку: сначала объединить два листа,
а затем найти сумму всех элементов. Неудачным вариантом будет сделать
следующее:

.. code:: py

   united_list = function1(list1, list2)
   elements_sum = function2(united_list)

``function1`` может вернуть ``None``, и нам не следует передавать такое
значение в ``function2``.

Правильнее будет сделать дополнительную проверку:

.. code:: py

   united_list = function1(list1, list2)
   if united_list:
       elements_sum = function2(united_list)


4. Ошибка Incompatible types in assignment (expression has type X, variable has type Y)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Python — динамический язык программирования. Это означает, что при
запуске программ переменные могут принимать значения разных типов.
Хотя это не запрещено в языке, это не самая лучшая практика.

Переиспользование переменных таким образом может сделать код более
уязвимым, потому как увеличивается вероятность сделать ошибку, которую
сложно будет потом найти. Поэтому ``MyPy`` подсвечивает такие переменные.

Можно избавиться от противоречия типов через переназначение типов:

Больше о `несовместимых переопределениях здесь
<https://mypy.readthedocs.io/en/stable/common_issues.html#redefinitions-with-incompatible-types>`__.

Больше об `особенностях стиля назначения типов MyPy здесь
<https://mypy.readthedocs.io/en/stable/faq.html#why-have-both-dynamic-and-static-typing>`__.

5. Интерпретатор не найден во время работы в Visual Studio Code
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Во многих случаях проблема состоит в том, как открыт проект в Visual Studio Code.
Удостоверьтесь, что Ваша корневая папка это ``202X-2-level-labs``, а не
какая-нибудь папка выше или папка лабораторной работы.

Больше информации о работе с Visual Studio Code Вы найдёте в :ref:`starting-guide-ru-label`.


Запуск тестов
-------------

1. Почему моя проверка в CI прервалась?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обычно это происходит из-за того, что проверка CI
превышает временной лимит, установленный на неё.

Причиной выхода за временные рамки может быть неверная работа
программы (например, бесконечный цикл). Если Вам кажется,
что проблема не в коде — напишите в чат, мы обязательно поможем
Вам разобраться.

Бывают случаи, когда проверки прерываются из-за того, что Вы сделали
``push`` в Ваш форк. Каждый раз, когда вы посылаете изменения в Ваш
форк, проверки в CI запускаются заново, независимо от того, завершены
ли проверки предыдущей версии кода.


2. Почему мои проверки CI не запускаются?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Обычно есть две причины, почему проверки не запускаются: Вас нет в
группе на GitHub, или у Вас есть конфликты с основным репозиторием.

Поэтому для решения проблемы в первую очередь удостоверьтесь,
что Вы приняли приглашение в группу на GitHub. Обычно их
высылают организованно в начале курса.

Если проблема в конфликтах, то Вам нужно обновить Ваш форк и
решить конфликты через ``git pull``.

Если Вы не знаете, как решать конфликты, обратитесь в чат за помощью.


3. Почему проверки CI и мой ментор ругаются на семинарские файлы?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Семинарские файлы нужны для того, чтобы научить Вас базовым знаниям о
работе с Python, но они не являются частью лабораторных работ, которые
Вы должны выполнить. Важно, чтобы в файлах Вашего Пулл Реквеста не было
ничего лишнего, что не относится к лабораторной работе Вы выполняете.

Поэтому если Вы случайно (или по просьбе семинариста) сделали ``push``
изменений в семинарских файлах, Вам нужно будет отменить их.

Чтобы отменить изменения, Вам нужно подтянуть версию семинарских файлов
из основного репозитория.

Выполните следующую команду в терминале Visual Studio Code, чтобы
удостовериться, что Ваш форк связан с основным репозиторием:

.. code:: bash

   git remote -v

У Вас должно быть два репозитория: `origin` and `upstream`,
один из которых — Ваш форк, а второй — основной репозиторий.

.. image:: ../images/FAQ/git_remote.png

Если у Вас не указан репозиторий `upstream`, выполните
следующую команду, чтобы добавить его:

.. code:: bash

   git remote add upstream <link-to-the-main-repository>

Теперь Вам нужно подтянуть состояние главного репозитория через
команду:

.. code:: bash

   git fetch upstream

После этого Вам нужно заменить содержимое локального состояния
Ваших семинарских файлов на состояние из основного репозитория.
Выполните команду, где `seminars` — путь до папки или файла,
который Вы хотите обновить.

.. code:: bash

    git checkout upstream/main seminars

После выполнения команды состояние Ваших локальных файлов будет
обновлено. Вам потребуется сделать ``add, commit, push`` новых
изменений, чтобы они появились в Вашем Пулл Реквесте.
